# network

- [OSI 7계층 / TCP-IP 4계층](#osi-7계층--tcp-ip-4계층)
- [3-way-handshake](#3-way-handshake)
- [TCP / UDP 차이점](#tcp--udp-차이점)
- [흐름제어 / 혼잡제어](#흐름제어--혼잡제어)
- [HTTP 버전별 차이](#http-버전별-차이)
- [HTTPS](#https)
- [rest / restful](#rest--restful)
- [RFC](#rfc)
- [쿠키 / 세션](#쿠키--세션)
- [로드밸런싱 알고리즘](#로드밸런싱-알고리즘)
- [L4, L7 스위치](#l4--l7-스위치)
 
--- 

## OSI 7계층 / TCP-IP 4계층

<br>

[위로](#network)

<br>

## 3-way-handshake
TCP 연결의 신뢰성과 순서보장을 위해 필수적인 절차

1. 클라이언트가 서버에 연결을 시도하면서 SYN 패킷을 보낸다.
2. 서버가 클라이언트의 SYN 요청을 받으면 서버의 SYN응답과 클라이언트의 요청에 대한 ACK 응답인 SYN+ACK 패킷을 클라이언트에게 보낸다.
3. 클라이언트는 SYN+ACK 패킷을 받고 서버에게 SYN 요청에 대한 응답으로 ACK 패킷을 보낸다.
* SYN : 연결이 이루어지도록 요청
* ACK : 요청을 확인했다는 응답

### 4-way-handshake
세션을 종료하기 위해 수행되는 절차

1. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다.
2. 서버는 요청을 받고 ACK 응답을 보낸다.
3. 서버는 데이터를 모두 보내고 통신이 끝나면 연결이 종료되었다는 FIN 플래그를 전송한다.
4. 클라이언트는 종료메시지를 확인했다는 ACK를 보낸다.

<br>

[위로](#network)

<br>

## TCP / UDP 차이점
* **TCP**
  * TCP는 연결형, 신뢰성 전송 프로토콜 이다.
  * 연결지향적 서비스를 제공하기 위해 데이터를 전송하기 전에 3way handshake를 통해 두 호스트의 전송 계층 사이에 논리적 연결을 설립한다.
  * 신뢰성 있는 서비스를 제공하기 위해 오류제어, 흐름제어, 혼잡제어 등을 실행한다.
  * 신뢰성을 보장하기 위해서 header가 더 크고 속도가 비교적 느리다는 단점이 있다.
  * TCP는 신뢰성이 중요한 통신(HTTP, File 전송 등)에 쓰인다.
* **UDP**
  * UDP는 비연결형 프로토콜로 3-way handshake 등의 세션 수립 과정이 없다.
  * 비신뢰성 프로토콜로 흐름제어, 오류제어, 혼잡 제어를 제공하지 않는다.
  * 이러한 단순성 덕분에 적은 양의 오버헤드갖고 수신여부를 확인하지 않아서 속도가 빠르다.
  * UDP는 실시간성이 중요한 통신(동영상 스트리밍 등)에 주로 사용된다.

<br>

[위로](#network)

<br>

## 흐름제어 / 혼잡제어

### 흐름제어
송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법 - 수신측이 너무 많은 패킷을 수신받지 않도록 하기 위함
<br>
송신측의 전송 속도가 너무 빨라 한 번에 수많은 패킷을 수신받아버린다면 수신측의 버퍼가 가득차 손실되는 패킷들이 발생한다.
<br>
* **Stop-And_waitPermalink**
  * 매번 전송한 패킷에 대한 확인 응답(ACK)을 받아야 그 다음 패킷을 전송하는 기법

* **Sliding Window (Go-Back-n ARQ)Permalink**
  * 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법
  * **윈도우 크기**
    * 최초의 윈도우 크기는 3-way-handshake 를 통해 수신측 윈도우 크기로 설정되며 이후 수신측 버퍼에 남아있는 공간에 따라 변한다.
    * 윈도우 크기는 수신측에서 송신측으로 응답(ACK)를 보낼때 TCP 헤더에 담아서 보낸다.

### 혼잡제어
하나의 라우터에 데이터가 몰리면 라우터가 처리하지 못하는데 이때 송신측에서 재전송을 하고 결국 네트워크를 혼잡하게 만들고 
<br>
오버플로우나 데이터손실을 발생시킨다. 혼잡제어는 송신측에서 데이터 전송속도를 제어하는 기법이다.
<br>
* **AIMDPermalink**
  * 처음 패킷을 하나씩 보내고 문제가 없으면 윈도우 크기를 1씩 증가시켜 전송한다. 전송에 실패하면 윈도우 크기를 반으로 줄인다.
  * 네트워크가 혼잡해 지고 나서 대역폭을 줄이는 방식이다.
* **Slow Start (느린시작)Permalink**
  * 각각의 ACK 패킷마다 윈도우사이즈를 1씩 증가시킨다. 즉, 1-2-4-8 이런식으로 윈도우 크기가 늘어난다.
  * 전송에 실패하면 윈도우사이즈를 1로 줄인다.
* **Fast Retransmit(빠른 재전송)Permalink**
  * 수신측에서 순서대로 패킷을 받지 않을경우 마지막 패킷의 다음 패킷 순번을 ACK 패킷에 실어 보낸다.
  * 이런 중복 ACK를 3개 받으면 재전송이 이루어지고, 혼잡상황으로 간주하고 윈도우 사이즈를 줄인다.
* **빠른 회복 (Fast Recovery)Permalink**
  * 빠른 회복은 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다.
  * 이 방법을 적용하면 혼잡 상황을 한 번 겪고나서부터는 AIMD 방식으로 동작한다.

<br>

[위로](#network)

<br>

## HTTP 버전별 차이
* **HTTP 1.0**
  * http header 개념이 도입되어 요청과 응답에 추가 됨
  * 버전정보 및 요청메서드가 같이 전송 됨
  * 상태코드가 추가되어 클라이언트에서 요청결과를 확인할 수 있게 됨
  * 헤더 필드가 추가됨
* **HTTP 1.1**
  * keep-alive
    * 한번 수립한 연결을 재사용 할 수 있게 설정할 수 있음 (시간제한)
    * 매번 3-way-handshake를 할 필요가 없게 됨
  * 파이프라이닝
    * 클라이언트가 여러 요청을 연달아 보낼때 각 요청에 대한 응답을 기다리지 않고 발생한 요청을 일단 전송하는 방식
    * 서버는 요청을 받은 순서에 따라 응답을 제공함
* **HTTP 2.0**
  * 바이너리 변환 계층이 추가되어 텍스트 대신 바이너리 데이터를 전송함
  * 하나의 연결 안에서 응답과 요청을 병렬로 처리
  * 헤더의 달라진 부분만 다시 전송하는 기법을 지원
* **HTTP 3.0**
  * TCP 통신 자체의 문제를 해결하기 위해 QUIC 프로토콜 위에서 동작
    * QUIC : TCP 의 신뢰성을 보장하는 기능들을 UDP를 기반으로 구현
* **GRPC?**

<br>

[위로](#network)

<br>

## HTTPS
HTTP 프로토콜은 암호화 되지 않은 텍스트로만 통신하기 때문에 보안문제가 있다. 이를 방지하기 위해 HTTP 통신에 신뢰성과 무결성을
<br>
추가할 필요가 있었고, 서로 자신이 신뢰할 수 있는 인증서를 사용하고 통신 내용은 SSL 또는 TLS라는 프로토콜로 암호화 한 방식이다.
<br>
[https](https://howhttps.works/ko/)

<br>

[위로](#network)

<br>

## rest / restful
완성된 HTML 파일이 아닌 데이터를 주고 받을 수 있는 표준 아키텍처. HTTP 프로토콜을 그대로 활용한다.
<br>
‘REST API’를 제공하는 웹 서비스를 ‘RESTful’하다고 할 수 있다.
* URI를 통해 자원을 명시
* HTTP 메서드를 활용해 CRUD를 구현

<br>

[위로](#network)

<br>

## RFC
주로 프로토콜(protocol) 및 파일 형식등이 주요 주제이며 승인된 문서는 유일한 일련 번호를 갖게 된다. (RFC-일련번호)
<br>
정식으로 일련 번호가 부여된 RFC 문서는 절대로 변경되거나 폐지되지 않으며 사실상의 표준이 된다.
<br>
ex)[http rfc 문서](https://datatracker.ietf.org/doc/html/rfc2616)

<br>

[위로](#network)

<br>

## 쿠키 / 세션

### 쿠키
* 쿠키 구성요소
  * name
    * 쿠키 이름
  * value
    * 쿠키의 저장된 값
  * max-age
    * 쿠키가 생성된 후 얼마나 유지될지 초 단위로 지정
    * 지정하지 않으면 세션쿠키, 지정하면 영속쿠키
  * domain
    * 쿠키가 사용하는 도메인 지정
    * 이 값이 현재 탐색 중인 도메인과 일치하지 않을 경우, "타사 쿠키"로 간주되며 브라우저에서 거부.
  * path
    * 쿠키가 전송될 서버상의 경로를 지정
  * secure
    * HTTPS 프로토콜을 통해해만 전송
  * httpOnly
    * HTTP(S) 프로토콜을 통해서만 접근할 수 있음
* 종류
  * 세션쿠키
    * 브라우저가 열려있는 동안에만 유지되는 쿠키
  * 영속쿠키
    * 설정된 만료기간까지 브라우저에 저장되는 쿠키
    * 브라우저를 닫아도 삭제되지 않음
```java
Cookie cookie = new Cookie("name","value");
response.addCookie(cookie); // 헤더에 set-cookie 하는 과정
```
* new Cookie() -> setXXX 로 값을 담아서 헤더에 담아 리턴
* 쿠키를 넣어주면 다음요청부터 자동으로 쿠키가 넘어오고 `@CookieValue` 어노테이션을 활용해 쿠키값 추출

### 세션
```java
HttpSession session = request.getSession(); //request -> HttpServletRequest
session.setAttribute("id",id);              //key, value 형태로 설정
```
* `HttpSession`을 사용하면 스프링은 자동으로 세션을 관리하고 클라이언트에 `JSESSIONID` 쿠키를 전달
  * 새로운 요청이 없으면 유효시간은 기본 30분이다.
  * 코드에 직접 또는 properties, yml 설정 파일에서 변경할 수 있다
* 분산 서버에서의 세션 관리
  * 외부 스토리지
    * Spring Session 외부 스토리지를 사용함으로써 분산환경에서 같은 세션데이터를 공유
  * Sticky Session
    * 클라이언트에 첫 요청에 응답을 준 서버에 계속 붙는 방법
    * Cookie를 사용하는 방법과 클라이언트의 IP tracking 방법이 있다
    * 단점
      * 특정 서버만 과부하가 올 수 있다.
      * 특정 서버 라우팅 Fail시 해당 서버에 붙어 있는 세션들이 소실될 수 있다.
  * Session Clustering
    * 여러 WAS의 세션을 하나로 묶어 동일한 세션으로 관리하는 방법
    * 단점
      * 새로운 서버가 하나 뜰 때마다 기존에 존재하던 WAS에 새로운 서버의 IP/Port를 입력해서 클러스터링해줘야 하는 번거로움이 있다.

<br>

[위로](#network)

<br>

## 로드밸런싱 알고리즘

<br>

[위로](#network)

<br>

## L4, L7 스위치
L4, L7 레이어는 언제쓰고 뭔지

<br>

[위로](#network)

<br>
